$date
	Wed Oct 04 17:39:40 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testbench $end
$var reg 32 ! IAddress [31:0] $end
$var reg 1 " clk $end
$var reg 1 # reset $end
$scope module dut $end
$var wire 32 $ IAddress [31:0] $end
$var wire 1 " clk $end
$var wire 1 # reset $end
$var wire 5 % rs2 [4:0] $end
$var wire 5 & rs1 [4:0] $end
$var wire 5 ' rd [4:0] $end
$var wire 7 ( opcode [6:0] $end
$var wire 7 ) funct7 [6:0] $end
$var wire 3 * funct3 [2:0] $end
$var wire 32 + SMout [31:0] $end
$var wire 32 , RUoutrs2 [31:0] $end
$var wire 32 - RUoutrs1 [31:0] $end
$var wire 32 . PCAddressIn [31:0] $end
$var wire 32 / PCAddress [31:0] $end
$var wire 32 0 Mr2B [31:0] $end
$var wire 32 1 Mr1A [31:0] $end
$var wire 32 2 MDDatawr [31:0] $end
$var wire 32 3 InmOut [31:0] $end
$var wire 25 4 ImmData [24:0] $end
$var wire 32 5 IMMExt [31:0] $end
$var wire 32 6 DMDataRd [31:0] $end
$var wire 1 7 CURUWr $end
$var wire 2 8 CURUDataWrSrc [1:0] $end
$var wire 3 9 CUImmSrc [2:0] $end
$var wire 1 : CUDMWr $end
$var wire 3 ; CUDMCtrl [2:0] $end
$var wire 5 < CUBrOp [4:0] $end
$var wire 4 = CUALUOp [3:0] $end
$var wire 1 > CUALUBSrc $end
$var wire 1 ? CUALUASrc $end
$var wire 1 @ BUNextPCSrc $end
$var wire 32 A ALURes [31:0] $end
$scope module decoder $end
$var wire 32 B instruction [31:0] $end
$var reg 3 C funct3 [2:0] $end
$var reg 7 D funct7 [6:0] $end
$var reg 25 E imm [24:0] $end
$var reg 7 F opcode [6:0] $end
$var reg 5 G rd [4:0] $end
$var reg 5 H rs1 [4:0] $end
$var reg 5 I rs2 [4:0] $end
$upscope $end
$scope module miALU $end
$var wire 4 J ALUOp [3:0] $end
$var wire 32 K ALUB [31:0] $end
$var wire 32 L ALUA [31:0] $end
$var reg 32 M ALURes [31:0] $end
$upscope $end
$scope module miBranchUnit $end
$var wire 32 N BURUrs2 [31:0] $end
$var wire 32 O BURUrs1 [31:0] $end
$var wire 5 P BUBrOp [4:0] $end
$var reg 1 @ BUNextPCSrc $end
$upscope $end
$scope module miControlUnit $end
$var wire 3 Q CUFunct3 [2:0] $end
$var wire 7 R CUFunct7 [6:0] $end
$var wire 7 S CUOpcode [6:0] $end
$var reg 1 ? CUALUASrc $end
$var reg 1 > CUALUBSrc $end
$var reg 4 T CUALUOp [3:0] $end
$var reg 5 U CUBrOp [4:0] $end
$var reg 3 V CUDMCtrl [2:0] $end
$var reg 1 : CUDMWr $end
$var reg 3 W CUImmSrc [2:0] $end
$var reg 2 X CURUDataWrSrc [1:0] $end
$var reg 1 7 CURUWr $end
$upscope $end
$scope module miDataMemory $end
$var wire 32 Y DMAddresss [31:0] $end
$var wire 3 Z DMCtrl [2:0] $end
$var wire 1 : DMWr $end
$var wire 32 [ DMDataWr [31:0] $end
$var reg 32 \ DMDataRd [31:0] $end
$upscope $end
$scope module miImmGen $end
$var wire 25 ] IMMinst [24:0] $end
$var wire 3 ^ IMMsrc [2:0] $end
$var reg 32 _ IMMout [31:0] $end
$upscope $end
$scope module miInstructionMemory $end
$var wire 32 ` IMAddress [31:0] $end
$var reg 32 a IMInstruction [31:0] $end
$var reg 32 b direccion [31:0] $end
$upscope $end
$scope module miMuxData $end
$var wire 32 c MDALURes [31:0] $end
$var wire 32 d MDDataRd [31:0] $end
$var wire 2 e MDRUDataWrSrc [1:0] $end
$var wire 32 f MDout [31:0] $end
$var reg 32 g MDDatawr [31:0] $end
$upscope $end
$scope module miMuxrs1 $end
$var wire 1 ? MR1ALUASrc $end
$var wire 32 h MR1RUrs1 [31:0] $end
$var wire 32 i MR1Address [31:0] $end
$var reg 32 j MR1A [31:0] $end
$upscope $end
$scope module miMuxrs2 $end
$var wire 1 > MR2ALUBSrc $end
$var wire 32 k MR2ImmExt [31:0] $end
$var wire 32 l MR2RUrs2 [31:0] $end
$var reg 32 m MR2B [31:0] $end
$upscope $end
$scope module miMuxsb $end
$var wire 32 n MSBALURes [31:0] $end
$var wire 1 @ MSBNextPCSrc $end
$var wire 32 o MSBout [31:0] $end
$var reg 32 p MSBin [31:0] $end
$upscope $end
$scope module miProgramCounter $end
$var wire 32 q IAddress [31:0] $end
$var wire 32 r PCin [31:0] $end
$var wire 1 " clk $end
$var wire 1 # reset $end
$var reg 32 s PCAddress [31:0] $end
$upscope $end
$scope module miRegistersUnit $end
$var wire 1 " CLK $end
$var wire 32 t RUDatawr [31:0] $end
$var wire 1 7 RUWr $end
$var wire 32 u RUoutrs1 [31:0] $end
$var wire 32 v RUoutrs2 [31:0] $end
$var wire 5 w RUrd [4:0] $end
$var wire 5 x RUrs1 [4:0] $end
$var wire 5 y RUrs2 [4:0] $end
$upscope $end
$scope module miSumador $end
$var wire 32 z SMAddress [31:0] $end
$var reg 32 { SMout [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx {
bx z
bx y
bx x
bx w
bx v
bx u
bx t
bx s
bx r
b0 q
bx p
bx o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
x@
x?
x>
bx =
bx <
bx ;
x:
bx 9
bx 8
x7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
bx %
b0 $
1#
0"
b0 !
$end
#5
b101 2
b101 g
b101 t
b101 A
b101 M
b101 Y
b101 c
b101 n
b101 0
b101 K
b101 m
b100 .
b100 p
b100 r
b101 5
b101 _
b101 k
b0 6
b0 \
b0 d
0@
b0 1
b0 L
b0 j
b0 =
b0 J
b0 T
b0 8
b0 X
b0 e
b0 ;
b0 V
b0 Z
0:
b10101 <
b10101 P
b10101 U
1>
0?
b0 9
b0 W
b0 ^
17
b1010000000000001 4
b1010000000000001 E
b1010000000000001 ]
b1 '
b1 G
b1 w
b0 ,
b0 N
b0 [
b0 l
b0 v
b101 %
b101 I
b101 y
b0 -
b0 O
b0 h
b0 u
b0 &
b0 H
b0 x
b0 )
b0 D
b0 R
b0 *
b0 C
b0 Q
b10011 (
b10011 F
b10011 S
b10100000000000010010011 3
b10100000000000010010011 B
b10100000000000010010011 a
b0 b
b100 +
b100 f
b100 o
b100 {
b0 /
b0 `
b0 i
b0 s
b0 z
1"
#10
0"
0#
#15
b1 5
b1 _
b1 k
0>
b10000000000010 4
b10000000000010 E
b10000000000010 ]
b10 '
b10 G
b10 w
b101 ,
b101 N
b101 [
b101 l
b101 v
b1 %
b1 I
b1 y
b110011 (
b110011 F
b110011 S
b1000 .
b1000 p
b1000 r
b100000000000100110011 3
b100000000000100110011 B
b100000000000100110011 a
b1 b
b1000 +
b1000 f
b1000 o
b1000 {
b100 /
b100 `
b100 i
b100 s
b100 z
1"
#20
0"
#25
b0xxxxxxxx 6
b0xxxxxxxx \
b0xxxxxxxx d
bx 2
bx g
bx t
bx A
bx M
bx Y
bx c
bx n
b0xxxxxxxxxxxxx 5
b0xxxxxxxxxxxxx _
b0xxxxxxxxxxxxx k
bx 0
bx K
bx m
bx 1
bx L
bx j
bx 4
bx E
bx ]
bx '
bx G
bx w
bx ,
bx N
bx [
bx l
bx v
bx %
bx I
bx y
bx -
bx O
bx h
bx u
bx &
bx H
bx x
bx )
bx D
bx R
bx *
bx C
bx Q
bx (
bx F
bx S
b1100 .
b1100 p
b1100 r
bx 3
bx B
bx a
b10 b
b1100 +
b1100 f
b1100 o
b1100 {
b1000 /
b1000 `
b1000 i
b1000 s
b1000 z
1"
#30
0"
#35
b10000 .
b10000 p
b10000 r
b11 b
b10000 +
b10000 f
b10000 o
b10000 {
b1100 /
b1100 `
b1100 i
b1100 s
b1100 z
1"
#40
0"
#45
b10100 .
b10100 p
b10100 r
b100 b
b10100 +
b10100 f
b10100 o
b10100 {
b10000 /
b10000 `
b10000 i
b10000 s
b10000 z
1"
#50
0"
#55
b11000 .
b11000 p
b11000 r
b101 b
b11000 +
b11000 f
b11000 o
b11000 {
b10100 /
b10100 `
b10100 i
b10100 s
b10100 z
1"
#60
0"
#65
b11100 .
b11100 p
b11100 r
b110 b
b11100 +
b11100 f
b11100 o
b11100 {
b11000 /
b11000 `
b11000 i
b11000 s
b11000 z
1"
